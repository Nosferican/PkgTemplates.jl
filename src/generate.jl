const TEST_UUID = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

"""
    generate(pkg::AbstractString, t::Template)
    generate(t::Template, pkg::AbstractString)

Generate a package named `pkg` from `t`.
"""
function generate(
    pkg::AbstractString,
    t::Template;
    gitconfig::Union{GitConfig, Nothing}=nothing,
)
    pkg = splitjl(pkg)
    pkg_dir = joinpath(t.dir, pkg)
    ispath(pkg_dir) && throw(ArgumentError("$pkg_dir already exists"))

    try
        # Create the directory with some boilerplate inside.
        Pkg.generate(pkg_dir)

        # Replace the UUID with something that's compatible with METADATA.
        project = joinpath(pkg_dir, "Project.toml")
        uuid = string(Pkg.METADATA_compatible_uuid(pkg))
        write(project, replace(read(project, String), r"uuid = .*" => "uuid = \"$uuid\""))

        if t.git
            # Initialize the repo.
            repo = LibGit2.init(pkg_dir)
            @info "Initialized Git repo at $pkg_dir"

            if gitconfig !== nothing
                # Configure the repo.
                repoconfig = GitConfig(repo)
                for c in LibGit2.GitConfigIter(gitconfig)
                    LibGit2.set!(repoconfig, unsafe_string(c.name), unsafe_string(c.value))
                end
            end

            # Commit and set the remote.
            LibGit2.commit(repo, "Initial commit")
            rmt = if t.ssh
                "git@$(t.host):$(t.user)/$pkg.jl.git"
            else
                "https://$(t.host)/$(t.user)/$pkg.jl"
            end
            # We need to set the remote in a strange way, see #8.
            close(LibGit2.GitRemote(repo, "origin", rmt))
            @info "Set remote origin to $rmt"
        end

        # Generate the files.
        files = vcat(
            "src/", "Project.toml",  # Created by Pkg.generate.
            gen_tests(pkg_dir, t),
            gen_require(pkg_dir, t),
            gen_readme(pkg_dir, t),
            gen_license(pkg_dir, t),
            vcat(map(p -> gen_plugin(p, t, pkg), values(t.plugins))...),
        )

        if t.git
            append!(files, gen_gitignore(pkg_dir, t))
            LibGit2.add!(repo, files...)
            LibGit2.commit(repo, "Files generated by PkgTemplates")
            @info "Committed $(length(files)) files/directories: $(join(files, ", "))"
        end

        # Add the new package to the current environment.
        Pkg.develop(PackageSpec(path=pkg_dir))

        @info "New package is at $pkg_dir"
    catch e
        rm(pkg_dir; recursive=true, force=true)
        rethrow(e)
    end
end

function generate(
    t::Template,
    pkg::AbstractString;
    gitconfig::Union{GitConfig, Nothing}=nothing,
)
    generate(pkg, t, gitconfig=gitconfig)
end

"""
    generate_interactive(pkg::AbstractString; fast::Bool=false) -> Template

Interactively create a template, and then generate a package with it. Arguments and
keywords are used in the same way as in [`generate`](@ref) and
[`interactive_template`](@ref).
"""
function generate_interactive(
    pkg::AbstractString;
    fast::Bool=false,
    gitconfig::Union{GitConfig, Nothing}=nothing,
)
    t = interactive_template(; fast=fast)
    generate(pkg, t; gitconfig=gitconfig)
    return t
end

# Create the test entrypoint.
function gen_tests(pkg_dir::AbstractString, t::Template)
    proj = Base.current_project()
    try
        # Add the Test dependency as a test-only dependency.
        # To avoid visual noise from adding/removing the dependency, insert it manually.
        Pkg.activate(pkg_dir)
        lines = split(read(joinpath(pkg_dir, "Project.toml"), String), "\n")
        dep = "Test = $(repr(TEST_UUID))"
        push!(lines, "[extras]", dep, "", "[targets]", "test = [\"Test\"]")
        gen_file(joinpath(pkg_dir, "Project.toml"), join(lines, "\n"))
        touch(joinpath(pkg_dir, "Manifest.toml"))  # File must exist to be modified by Pkg.
        Pkg.update()  # Clean up both Manifest.toml and Project.toml.
    finally
        proj === nothing ? Pkg.activate() : Pkg.activate(proj)
    end

    pkg = basename(pkg_dir)
    text = """
        using $pkg
        using Test

        @testset "$pkg.jl" begin
            # Write your own tests here.
        end
        """

    gen_file(joinpath(pkg_dir, "test", "runtests.jl"), text)
    return ["test/"]
end

# Create the package REQUIRE file.
function gen_require(pkg_dir::AbstractString, t::Template)
    text = "julia $(version_floor(t.julia_version))\n"
    gen_file(joinpath(pkg_dir, "REQUIRE"), text)
    return ["REQUIRE"]
end

# Create the package README.
function gen_readme(pkg_dir::AbstractString, t::Template)
    pkg = basename(pkg_dir)
    text = "# $pkg\n"
    done = []
    # Generate the ordered badges first, then add any remaining ones to the right.
    foreach(BADGE_ORDER) do T
        if haskey(t.plugins, T)
            text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
            push!(done, T)
        end
    end
    foreach(setdiff(keys(t.plugins), done)) do T
        text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
    end

    gen_file(joinpath(pkg_dir, "README.md"), text)
    return ["README.md"]
end

# Create the package gitignore.
function gen_gitignore(pkg_dir::AbstractString, t::Template)
    pkg = basename(pkg_dir)
    init = [".DS_Store", "/dev/"]
    entries = mapfoldl(p -> gitignore(p), append!, values(t.plugins); init=init)
    if !t.manifest && !in("Manifest.toml", entries)
        push!(entries, "/Manifest.toml")  # Only ignore manifests at the repo root.
    end
    unique!(sort!(entries))
    text = join(entries, "\n")

    gen_file(joinpath(pkg_dir, ".gitignore"), text)
    files = [".gitignore"]
    t.manifest && push!(files, "Manifest.toml")
    return files
end

# Create the package license.
function gen_license(pkg_dir::AbstractString, t::Template)
    isempty(t.license) && return String[]

    text = "Copyright (c) $(year(today())) $(t.authors)\n"
    text *= read_license(t.license)

    gen_file(joinpath(pkg_dir, "LICENSE"), text)
    return ["LICENSE"]
end
