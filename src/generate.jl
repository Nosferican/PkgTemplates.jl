const TEST_UUID = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

"""
    generate(pkg::AbstractString, t::Template)
    generate(t::Template, pkg::AbstractString)

Generate a package named `pkg` from `t`.
"""
function generate(
    pkg::AbstractString,
    t::Template;
    gitconfig::Union{GitConfig, Nothing}=nothing,
)
    pkg = splitjl(pkg)
    pkg_dir = joinpath(t.dir, pkg)
    ispath(pkg_dir) && throw(ArgumentError("$pkg_dir already exists"))

    try
        # Create the directory with some boilerplate inside.
        Pkg.generate(pkg_dir)

        # Replace the UUID with something that's compatible with METADATA.
        project = joinpath(pkg_dir, "Project.toml")
        uuid = string(Pkg.METADATA_compatible_uuid(pkg))
        write(project, replace(read(project, String), r"uuid = .*" => "uuid = \"$uuid\""))

        if t.git
            # Initialize the repo.
            repo = LibGit2.init(pkg_dir)
            @info "Initialized Git repo at $pkg_dir"

            if gitconfig !== nothing
                # Configure the repo.
                repoconfig = GitConfig(repo)
                for c in LibGit2.GitConfigIter(gitconfig)
                    LibGit2.set!(repoconfig, unsafe_string(c.name), unsafe_string(c.value))
                end
            end

            # Commit and set the remote.
            LibGit2.commit(repo, "Initial commit")
            rmt = if t.ssh
                "git@$(t.host):$(t.user)/$pkg.jl.git"
            else
                "https://$(t.host)/$(t.user)/$pkg.jl"
            end
            # We need to set the remote in a strange way, see #8.
            close(LibGit2.GitRemote(repo, "origin", rmt))
            @info "Set remote origin to $rmt"
        end

        # Generate the files.
        gen_tests(t, pkg_dir)
        gen_require(t, pkg_dir)
        gen_readme(t, pkg_dir)
        gen_license(t, pkg_dir)
        gen_gitignore(t, pkg_dir)
        gen_license(t, pkg_dir)
        foreach(p -> gen_plugin(p, t, pkg_dir), values(t.plugins))

        if t.git
            # Commit the files.
            LibGit2.add!(repo, ".")
            LibGit2.commit(repo, "Files generated by PkgTemplates")
            @info "Committed generated files"
        end

        # Add the new package to the current environment.
        Pkg.develop(PackageSpec(path=pkg_dir))

        @info "New package is at $pkg_dir"
    catch e
        rm(pkg_dir; recursive=true, force=true)
        rethrow(e)
    end
end

function generate(
    t::Template,
    pkg::AbstractString;
    gitconfig::Union{GitConfig, Nothing}=nothing,
)
    generate(pkg, t, gitconfig=gitconfig)
end

"""
    generate_interactive(pkg::AbstractString; fast::Bool=false) -> Template

Interactively create a template, and then generate a package with it. Arguments and
keywords are used in the same way as in [`generate`](@ref) and
[`interactive_template`](@ref).
"""
function generate_interactive(
    pkg::AbstractString;
    fast::Bool=false,
    gitconfig::Union{GitConfig, Nothing}=nothing,
)
    t = interactive_template(; fast=fast)
    generate(pkg, t; gitconfig=gitconfig)
    return t
end

# The make_* functions return (path, text) tuples, which are files that should be written.
# The gen_* functions write those files, along with any other required file manipulation.

function make_tests(t::Template, pkg_dir::AbstractString)
    pkg = basename(pkg_dir)
    text = """
        using $pkg
        using Test

        @testset "$pkg.jl" begin
            # Write your own tests here.
        end
        """
    return [(joinpath(pkg_dir, "test", "runtests.jl"), text)]
end

function make_require(t::Template, pkg_dir::AbstractString)
    text = "julia $(version_floor(t.julia_version))"
    return [(joinpath(pkg_dir, "REQUIRE"), text)]
end

function make_readme(t::Template, pkg_dir::AbstractString)
    pkg = basename(pkg_dir)
    text = "# $pkg\n"

    # Generate the ordered badges first, then add any remaining ones to the right.
    done = DataType[]
    foreach(BADGE_ORDER) do T
        if haskey(t.plugins, T)
            text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
            push!(done, T)
        end
    end
    foreach(setdiff(keys(t.plugins), done)) do T
        text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
    end

    return [(joinpath(pkg_dir, "README.md"), text)]
end

function make_gitignore(t::Template, pkg_dir::AbstractString)
    t.git || return ()

    init = [".DS_Store", "/dev/"]
    entries = mapfoldl(p -> gitignore(p), append!, values(t.plugins); init=init)

    # Only ignore manifests at the repo root.
    t.manifest || "Manifest.toml" in entries || push!(entries, "/Manifest.toml")

    unique!(sort!(entries))
    text = join(entries, "\n")

    return [(joinpath(pkg_dir, ".gitignore"), text)]
end

function make_license(t::Template, pkg_dir::AbstractString)
    isempty(t.license) && return ()
    text = "Copyright (c) $(year(today())) $(t.authors)\n"
    text *= read_license(t.license)
    return [(joinpath(pkg_dir, "LICENSE"), text)]
end

for f in (:require, :readme, :gitignore, :license)
    gen = Symbol(:gen_, f)
    make = Symbol(:make_, f)
    @eval $gen(t::Template, pkg_dir::AbstractString) = foreach(gen_file, $make(t, pkg_dir))
end

function gen_tests(t::Template, pkg_dir::AbstractString,)
    proj = Base.current_project()
    try
        # Add the Test dependency as a test-only dependency.
        # To avoid visual noise from adding/removing the dependency, insert it manually.
        Pkg.activate(pkg_dir)
        lines = split(read(joinpath(pkg_dir, "Project.toml"), String), "\n")
        dep = "Test = $(repr(TEST_UUID))"
        push!(lines, "[extras]", dep, "", "[targets]", "test = [\"Test\"]")
        gen_file(joinpath(pkg_dir, "Project.toml"), join(lines, "\n"))
        touch(joinpath(pkg_dir, "Manifest.toml"))  # File must exist to be modified by Pkg.
        Pkg.update()  # Clean up both Manifest.toml and Project.toml.
    finally
        proj === nothing ? Pkg.activate() : Pkg.activate(proj)
    end

    foreach(gen_file, make_tests(t, pkg_dir))
end
